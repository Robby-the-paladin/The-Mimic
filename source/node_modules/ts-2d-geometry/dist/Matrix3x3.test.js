"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Matrix3x3_1 = require("./Matrix3x3");
var ts_optional_1 = require("@ruffy/ts-optional");
test('constructor should create Matrix', function () {
    var m = new Matrix3x3_1.Matrix3x3([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
    ]);
    expect(m.get(0, 0)).toBe(0);
    expect(m.get(0, 1)).toBe(1);
    expect(m.get(0, 2)).toBe(2);
    expect(m.get(1, 0)).toBe(3);
    expect(m.get(1, 1)).toBe(4);
    expect(m.get(1, 2)).toBe(5);
    expect(m.get(2, 0)).toBe(6);
    expect(m.get(2, 1)).toBe(7);
    expect(m.get(2, 2)).toBe(8);
});
[
    { m: [1, 0, 0, 0, 1, 0, 0, 0, 1], tm: [1, 0, 0, 0, 1, 0, 0, 0, 1] },
    { m: [1, 2, 3, 4, 5, 6, 7, 8, 9], tm: [1, 4, 7, 2, 5, 8, 3, 6, 9] },
].forEach(function (_a) {
    var m = _a.m, tm = _a.tm;
    test("transpose should transpose " + m + " to " + tm, function () {
        var ma = Matrix3x3_1.Matrix3x3.fromArray(m);
        expect(ma.transpose()).toEqual(Matrix3x3_1.Matrix3x3.fromArray(tm));
    });
});
[
    { m: [1, 0, 0, 0, 1, 0, 0, 0, 1], im: ts_optional_1.some([1, 0, 0, 0, 1, 0, 0, 0, 1]) },
    { m: [1, 0, 0, 0, 1, 0, 0, 0, 2], im: ts_optional_1.some([1, 0, 0, 0, 1, 0, 0, 0, 1 / 2.0]) },
    { m: [1, 2, 3, 4, 5, 6, 7, 8, 10], im: ts_optional_1.some([-2, -4, 3, -2, 11, -6, 3, -6, 3]
            .map(function (v) { return v / 3.0; })) },
].forEach(function (_a) {
    var m = _a.m, im = _a.im;
    test('inverse should return inverse of matrix', function () {
        var ma = Matrix3x3_1.Matrix3x3.fromArray(m);
        expect(ma.inverse()).toEqual(im.map(function (m) { return Matrix3x3_1.Matrix3x3.fromArray(m); }));
    });
});
test('translation matrix should move a vector accordingly', function () {
    var m = Matrix3x3_1.Matrix3x3.translation(5, 4);
    expect(m.times([0, 0, 1])).toEqual([5, 4, 1]);
});
test('rotation matrix should transform a vector accordingly', function () {
    var m = Matrix3x3_1.Matrix3x3.rotationDegrees(90);
    expect(m.times([1, 0, 1])[0]).toBeCloseTo(0, 2);
    expect(m.times([1, 0, 1])[1]).toBeCloseTo(-1, 2);
});
[
    { ma: [1, 0, 0, 0, 1, 0, 0, 0, 1], d: 1 },
    { ma: [1, 0, 0, 0, -1, 0, 0, 0, 1], d: -1 },
    { ma: [1, 2, 3, 4, 5, 6, 7, 8, 10], d: -3 },
]
    .forEach(function (_a) {
    var ma = _a.ma, d = _a.d;
    test('det should return determinant of matrix', function () {
        var m = Matrix3x3_1.Matrix3x3.fromArray(ma);
        expect(m.det()).toEqual(d);
    });
});
test('timesMatrix should multiply matrix with matrix', function () {
    var m = Matrix3x3_1.Matrix3x3.fromArray([1, 0, 0,
        0, 2, 0,
        0, 0, 3]);
    expect(m.timesMatrix(m)).toEqual(Matrix3x3_1.Matrix3x3.fromArray([1, 0, 0,
        0, 4, 0,
        0, 0, 9]));
});
test('timesMatrix should multiply with self being left matrix', function () {
    var m = Matrix3x3_1.Matrix3x3.fromArray([1, 1, 1,
        0, 0, 0,
        0, 0, 0]);
    var m2 = Matrix3x3_1.Matrix3x3.fromArray([1, 0, 0,
        1, 0, 0,
        1, 0, 0]);
    expect(m.timesMatrix(m2)).toEqual(Matrix3x3_1.Matrix3x3.fromArray([3, 0, 0,
        0, 0, 0,
        0, 0, 0]));
});
test('times should multiply vector with matrix', function () {
    var m = Matrix3x3_1.Matrix3x3.fromArray([1, 0, 0,
        0, 2, 0,
        0, 0, 3]);
    var v = [1, 1, 1];
    expect(m.times(v)).toEqual([1, 2, 3]);
});
//# sourceMappingURL=Matrix3x3.test.js.map