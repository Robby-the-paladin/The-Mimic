"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lineSegment = exports.LineSegment = void 0;
var Point_1 = require("./Point");
var Line_1 = require("./Line");
var Interval_1 = require("./Interval");
var GlobalConfig_1 = __importDefault(require("./GlobalConfig"));
/**
 * A LineSegment is defined by two points, it represents the line between these points.
 */
var LineSegment = /** @class */ (function () {
    function LineSegment(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
    }
    /**
     * Creates a LineSegment from four numbers. The first two being x and y from the start point
     * of the line segment, the last two the x and y value of the end point.
     */
    LineSegment.fromValues = function (x1, y1, x2, y2) {
        return lineSegment(x1, y1, x2, y2);
    };
    /**
     * Creates a LineSegment from an array of numbers. The array must be at least 4 elements long
     * and these first 4 values will be used as [x1, y1, x2, y2].
     */
    LineSegment.fromArray = function (a) {
        return new LineSegment(new Point_1.Point(a[0], a[1]), new Point_1.Point(a[2], a[3]));
    };
    /**
     * Gets the closest point on the line segment to the given point.
     * @param p2
     * Point to get closest point for.
     */
    LineSegment.prototype.closestPoint = function (p2) {
        var l = new Line_1.Line(this.p1, this.p2.minus(this.p1));
        var factor = l.projectFactor(p2);
        if (factor >= 1) {
            return this.p2;
        }
        if (factor <= 0) {
            return this.p1;
        }
        return l.project(p2);
    };
    /**
     * Returns the point where the given line intersect this line segment, if such
     * point exists. If the line and the line segment are parallel and on the same
     * line, none is returned because there is no one unique point of intersect.
     */
    LineSegment.prototype.intersectForLine = function (l) {
        var _this = this;
        var intersect = this.asLine().intersect(l);
        return intersect.filter(function (p) { return _this.containsPoint(p); });
    };
    /**
     * Verifies if the given point is on the line that would be defined by p1 and p2 of this line
     * segment.
     * @param p
     * The point to verify
     */
    LineSegment.prototype.onLine = function (p) {
        var v1 = p.minus(this.p1);
        var v2 = this.p2.minus(this.p1);
        return Math.abs(v1.cross(v2)) < GlobalConfig_1.default.precisionSquared;
    };
    /**
     * Returns boolean whether this segment is placed to the right of given point.
     * This is defined as if whether a line segment starting at point p, and going
     * to x = infinity, intersect this line segment.
     * If the point is on the line segment, false is returned,
     * @param p
     * Point to check if line segemnt is to the right of
     * @param intervalType
     * Tells us if endpoints should be part of interval or not.
     */
    LineSegment.prototype.rightOfPoint = function (p, intervalType) {
        if (intervalType === void 0) { intervalType = Interval_1.IntervalType.OpenEnd; }
        var heightInterval = this.getHeightInterval(intervalType);
        if (!heightInterval.contains(p.y)) {
            return false;
        }
        // the line is parallel, we make sure that x is < p1.x and p2.x
        if (p.y === this.p1.y && p.y === this.p2.y) {
            return p.x < Math.min(this.p1.x, this.p2.x);
        }
        var _a = this.p1.y >= this.p2.y ? [this.p1, this.p2]
            : [this.p2, this.p1], topPoint = _a[0], bottomPoint = _a[1];
        return p.minus(topPoint).cross(bottomPoint.minus(topPoint)) >= 0;
    };
    /**
     * Returns new line segment that is like this segment moved.
     * @param x
     * @param y
     */
    LineSegment.prototype.translate = function (x, y) {
        return new LineSegment(this.p1.translate(x, y), this.p2.translate(x, y));
    };
    /**
     * Checks if this line segment is parallel to another line segment.
     * Parallel will also hold true if the line segments overlap,
     * or lie on the same axis. I.e. [0,0] -> [1,0] is deemed parallel to [1,0] -> [2,0]
     * @param other
     * The line segment to do the comparison on.
     */
    LineSegment.prototype.parallel = function (other) {
        var v1 = this.asVector();
        var v2 = other.asVector();
        return Math.abs(v1.cross(v2)) < GlobalConfig_1.default.precisionSquared;
    };
    /**
     * Checks if there is any overlapping point between the two line segments.
     * This is like intersect, but returns a boolean and will also return
     * true if the line segments are parallel and share one or more common points.
     */
    LineSegment.prototype.overlap = function (other) {
        var intersect = this.intersect(other).nonEmpty();
        var overlap = intersect
            || other.containsPoint(this.p1)
            || other.containsPoint(this.p2)
            || this.containsPoint(other.p1);
        return overlap;
    };
    /**
     * Gives a string representing this line segment that's readable.
     */
    LineSegment.prototype.toString = function () {
        return "(" + this.p1.toString() + " -> " + this.p2.toString() + ")";
    };
    LineSegment.prototype.getHeightInterval = function (paramIntervalType) {
        var intervalType = paramIntervalType;
        if (this.p1.y < this.p2.y) {
            return new Interval_1.Interval(this.p1.y, this.p2.y, intervalType);
        }
        if (intervalType === Interval_1.IntervalType.OpenStart) {
            intervalType = Interval_1.IntervalType.OpenEnd;
        }
        else if (intervalType === Interval_1.IntervalType.OpenEnd) {
            intervalType = Interval_1.IntervalType.OpenStart;
        }
        return new Interval_1.Interval(this.p2.y, this.p1.y, intervalType);
    };
    /**
     * Returns the vector defined by going from point p1 to point p2
     */
    LineSegment.prototype.asVector = function () {
        return this.p2.minus(this.p1);
    };
    /**
     * Returns the point where the given line segments intersect, if such point exists.
     * If the line segments are parallel none is return since the intersect can potentially
     * be many points.
     * @param ls2
     * The other line segment.
     * @param otherInterval
     * How the endpoints should be interpreted of the other line segment.
     * @param thisInterval
     * How the endpoints should be interpreted on this line segment.
     */
    LineSegment.prototype.intersect = function (ls2, otherInterval, thisInterval) {
        var _this = this;
        if (otherInterval === void 0) { otherInterval = Interval_1.IntervalType.Closed; }
        if (thisInterval === void 0) { thisInterval = Interval_1.IntervalType.Closed; }
        var l1 = this.asLine();
        var l2 = ls2.asLine();
        var intersect = l1.intersect(l2);
        return intersect.filter(function (intersect) { return _this.containsPoint(intersect, thisInterval)
            && ls2.containsPoint(intersect, otherInterval); });
    };
    /**
     * Returns a new Line Segment where p1 equals the new p instead.
     * @param p
     */
    LineSegment.prototype.startFrom = function (p) {
        return new LineSegment(p, this.p2);
    };
    /**
     * Return true if the points of this line segment equals the points of the other line segment.
     * @param ls
     * Line segment to compare with.
     */
    LineSegment.prototype.equals = function (ls) {
        return this.p1.equals(ls.p1) && this.p2.equals(ls.p2);
    };
    /**
     * Returns if the given point exists on this line segment or not.
     * @param p
     */
    LineSegment.prototype.containsPoint = function (p, interval) {
        if (interval === void 0) { interval = Interval_1.IntervalType.Closed; }
        var p1p = p.minus(this.p1);
        var p1p2 = this.p2.minus(this.p1);
        var dotProd = p1p.dot(p1p2);
        var crossProd = p1p.cross(p1p2);
        var pointOnSegment = dotProd >= 0
            && dotProd <= p1p2.square() + GlobalConfig_1.default.precisionSquared
            && Math.abs(crossProd) < GlobalConfig_1.default.precision;
        if (!pointOnSegment) {
            return false;
        }
        if (interval === Interval_1.IntervalType.Open) {
            return !p.equals(this.p1) && !p.equals(this.p2);
        }
        if (interval === Interval_1.IntervalType.OpenEnd) {
            return !p.equals(this.p2);
        }
        if (interval === Interval_1.IntervalType.OpenStart) {
            return !p.equals(this.p1);
        }
        return true;
    };
    LineSegment.prototype.asLine = function () {
        return new Line_1.Line(this.p1, this.p2.minus(this.p1));
    };
    /**
     * Returns a new Line Segment where p1 and p2 have changed places.
     */
    LineSegment.prototype.flip = function () {
        return new LineSegment(this.p2, this.p1);
    };
    return LineSegment;
}());
exports.LineSegment = LineSegment;
/**
 * Creates a line segment.
 */
function lineSegment(x1, y1, x2, y2) {
    return new LineSegment(new Point_1.Point(x1, y1), new Point_1.Point(x2, y2));
}
exports.lineSegment = lineSegment;
//# sourceMappingURL=LineSegment.js.map