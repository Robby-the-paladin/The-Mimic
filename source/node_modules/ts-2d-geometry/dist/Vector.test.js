"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Vector_1 = require("./Vector");
var Point_1 = require("./Point");
var v = new Vector_1.Vector(1, 2);
beforeEach(function () {
    v = new Vector_1.Vector(1, 2);
});
test('constructor should create Vector', function () {
    expect(v.x).toBe(1);
    expect(v.y).toBe(2);
});
test('constructor should initialize w to 1 if not defined', function () {
    expect(v.w).toBe(1);
});
test('constructor should initialize w if defined', function () {
    v = new Vector_1.Vector(1, 2, 2);
    expect(v.w).toBe(2);
});
test('dot should do dot product with vector', function () {
    var scalar = v.dot(v);
    expect(scalar).toBe(5);
});
test('scale should return new vector by multiplying the vector with the factor', function () {
    var nv = v.scale(2);
    expect(v).not.toEqual(nv);
    expect(nv.x).toBe(2);
    expect(nv.y).toBe(4);
});
test('parallel should return true when vector points in same direction', function () {
    var v1 = Vector_1.vector(1, 0);
    var v2 = Vector_1.vector(2, 0);
    expect(v1.parallel(v2)).toBeTruthy();
});
test('parallel should return true when vector points in opposite direction', function () {
    var v1 = Vector_1.vector(1, 0);
    var v2 = Vector_1.vector(-2, 0);
    expect(v1.parallel(v2)).toBeTruthy();
});
test('parallel should return false when vector points in other direction', function () {
    var v1 = Vector_1.vector(1, 0);
    var v2 = Vector_1.vector(2, 1);
    expect(v1.parallel(v2)).toBeFalsy();
    expect(v1.parallel(v2.reverse())).toBeFalsy();
});
var xVector = Vector_1.vector(1, 0);
[
    { v: Vector_1.vector(2, 1), expected: Vector_1.vector(0, 1) },
    { v: Vector_1.vector(2, 3), expected: Vector_1.vector(0, 3) },
    { v: Vector_1.vector(2, -3), expected: Vector_1.vector(0, -3) },
].forEach(function (_a) {
    var v = _a.v, expected = _a.expected;
    test("perpendicularComponentTo " + xVector + " is " + expected + " for " + v, function () {
        expect(v.perpendicularComponentTo(xVector)).toEqual(expected);
    });
});
test('perpendicularComponentTo null vector is input vector', function () {
    var v = Vector_1.vector(12, 3);
    expect(v.perpendicularComponentTo(Vector_1.Vector.null)).toEqual(v);
});
[
    { v: Vector_1.vector(2, 1), expected: Vector_1.vector(2, 0) },
    { v: Vector_1.vector(2, 3), expected: Vector_1.vector(2, 0) },
    { v: Vector_1.vector(2, -3), expected: Vector_1.vector(2, 0) },
].forEach(function (_a) {
    var v = _a.v, expected = _a.expected;
    test("projectOnto " + xVector + " is " + expected + " for " + v, function () {
        expect(v.projectOnto(xVector)).toEqual(expected);
    });
});
test('projectOnto null vector is input vector', function () {
    var v = Vector_1.vector(12, 3);
    expect(v.projectOnto(Vector_1.Vector.null)).toEqual(v);
});
[
    { v1: Vector_1.vector(2, 1), v2: Vector_1.vector(0, 1), expected: Vector_1.vector(2, 2) },
    { v1: Vector_1.vector(4, 2), v2: Vector_1.vector(1, -1), expected: Vector_1.vector(5, 1) },
    { v1: Vector_1.vector(2, 1), v2: Vector_1.vector(0, 0), expected: Vector_1.vector(2, 1) },
].forEach(function (_a) {
    var v1 = _a.v1, v2 = _a.v2, expected = _a.expected;
    test("plus of " + v1 + " and " + v2 + " equals " + expected, function () {
        expect(v1.plus(v2)).toEqual(expected);
    });
});
[
    { v1: Vector_1.vector(2, 1), v2: Vector_1.vector(0, 1), expected: Vector_1.vector(2, 0) },
    { v1: Vector_1.vector(4, 2), v2: Vector_1.vector(1, -1), expected: Vector_1.vector(3, 3) },
    { v1: Vector_1.vector(2, 1), v2: Vector_1.vector(0, 0), expected: Vector_1.vector(2, 1) },
].forEach(function (_a) {
    var v1 = _a.v1, v2 = _a.v2, expected = _a.expected;
    test("minus of " + v1 + " and " + v2 + " equals " + expected, function () {
        expect(v1.minus(v2)).toEqual(expected);
    });
});
test('isNullVector should return false for non null vector', function () {
    var v = new Vector_1.Vector(1, 0);
    expect(v.isNullVector()).toBeFalsy();
});
test('isNullVector should return true for null vector', function () {
    var v = new Vector_1.Vector(0, 0);
    expect(v.isNullVector()).toBeTruthy();
});
test('square should return vector dot itself.', function () {
    expect(v.square()).toBe(v.dot(v));
});
test('norm2 should return euklidean length of vector.', function () {
    expect(v.norm2()).toBe(Math.sqrt(5));
});
test('cross should return the size of the cross product', function () {
    var v2 = new Vector_1.Vector(2, 1);
    expect(v.cross(v2)).toBe(-3);
});
test('clockwisePerpendeicular should return the clockwise perpendicular vector', function () {
    var res = v.clockwisePerpendicular();
    expect(res.x).toBe(v.y);
    expect(res.y).toBe(-v.x);
});
test('reverse should return the reversed vector.', function () {
    var res = v.reverse();
    expect(res.x).toBe(-v.x);
    expect(res.y).toBe(-v.y);
});
test('normed should throw error if norm2 = 0', function () {
    expect(function () {
        new Vector_1.Vector(0, 0).normed();
    }).toThrow();
});
test('normed should return normalized version of vector', function () {
    expect(new Vector_1.Vector(2, 0).normed()).toEqual(new Vector_1.Vector(1, 0));
});
test('asPoint should return vector as point', function () {
    expect(v.asPoint()).toEqual(new Point_1.Point(v.x, v.y));
});
//# sourceMappingURL=Vector.test.js.map