"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformation = void 0;
var Matrix3x3_1 = require("./Matrix3x3");
var Point_1 = require("./Point");
var Polygon_1 = require("./Polygon");
/**
 * A transformation can be applied to geometrical shaped to move them according to specific rules.
 *
 * Under the hood the transformation is basically an Matrix, but
 * it works as an adapter that glues together the interface
 * of the geometrical shapes with the matrix classes.
 */
var Transformation = /** @class */ (function () {
    /**
     *
     * @param m
     * The transformation as describe by a matrix.
     */
    function Transformation(m) {
        this.m = m;
    }
    /**
     * Returns a builder that can construct a transformation.
     */
    Transformation.builder = function () {
        return new TransformationBuilder();
    };
    /**
     * Applies this transformation to a point.
     */
    Transformation.prototype.applyToPoint = function (p) {
        var a = [p.x, p.y, 1];
        var result = this.m.times(a);
        return Point_1.Point.fromValues(result[0], result[1]);
    };
    /**
     * Returns a string representation of the matrix that represents this
     * transformation.
     */
    Transformation.prototype.toString = function () {
        return this.m.toString();
    };
    /**
     * Applies this transformation to a polygon.
     */
    Transformation.prototype.applyToPolygon = function (pol) {
        var _this = this;
        var points = pol.points();
        var newPoints = points.map(function (p) { return [p.x, p.y, 1]; })
            .map(function (a) { return _this.m.times(a); })
            .map(function (res) { return Point_1.Point.fromValues(res[0], res[1]); });
        return Polygon_1.Polygon.fromPoints(newPoints);
    };
    return Transformation;
}());
exports.Transformation = Transformation;
/**
 * Builds a transformation by stringing together an array of
 * transformation matrices. With the first one defined in the
 * builder being the first one that is applied to the geometrical
 * shape etc.
 */
var TransformationBuilder = /** @class */ (function () {
    function TransformationBuilder() {
        this.operations = [];
    }
    TransformationBuilder.prototype.build = function () {
        var transformationMatrix = this.operations.reduce(function (a, v) { return v.timesMatrix(a); }, Matrix3x3_1.Matrix3x3.identity());
        return new Transformation(transformationMatrix);
    };
    TransformationBuilder.fromOperations = function (operations) {
        var builder = new TransformationBuilder();
        builder.operations = operations;
        return builder;
    };
    /**
     * Rotates the coordinates the given amount of degrees around origo.
     */
    TransformationBuilder.prototype.withRotationDegrees = function (degrees) {
        var rotationMatrix = Matrix3x3_1.Matrix3x3.rotationDegrees(degrees);
        return this.createNewBuilder(rotationMatrix);
    };
    /**
     * Rotates so that the positive x axis points in the direction
     * of the given vector direction.
     * @param vec
     * The vector that will become the new x-axis in the new coordinate system.
     */
    TransformationBuilder.prototype.withVectorRotation = function (vec) {
        var v = vec.normed();
        var rotationMatrix = Matrix3x3_1.Matrix3x3.fromArray([v.x, -v.y, 0, v.y, v.x, 0, 0, 0, 1]);
        return this.createNewBuilder(rotationMatrix);
    };
    /**
     * Moves the points the given distance in x and y.
     */
    TransformationBuilder.prototype.withTranslation = function (x, y) {
        var translationMatrix = Matrix3x3_1.Matrix3x3.translation(x, y);
        return this.createNewBuilder(translationMatrix);
    };
    /**
     * Adds an arbitrary transformation matrix to the builder.
     */
    TransformationBuilder.prototype.withMatrix = function (m) {
        return this.createNewBuilder(m);
    };
    /**
     * Scales the coordinate with the given factors. If only xFactor is given, the same factor
     * will be used to scale in y direction.
     * @param xFactor
     * The factor that coordinates should be multiplied in the x-axis
     * @param yFactor
     * The factor that coordintaes should be multiplied in the y-axis
     */
    TransformationBuilder.prototype.withScale = function (xFactor, yFactor) {
        var yScale = yFactor ? yFactor : xFactor;
        var a = [xFactor, 0, 0, 0, yScale, 0, 0, 0, 1];
        var scaleMatrix = Matrix3x3_1.Matrix3x3.fromArray(a);
        return this.createNewBuilder(scaleMatrix);
    };
    TransformationBuilder.prototype.createNewBuilder = function (additionalOperation) {
        var newOperations = __spreadArrays(this.operations);
        newOperations.push(additionalOperation);
        return TransformationBuilder.fromOperations(newOperations);
    };
    return TransformationBuilder;
}());
//# sourceMappingURL=Transformation.js.map