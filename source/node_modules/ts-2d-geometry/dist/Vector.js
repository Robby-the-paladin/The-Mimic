"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vector = exports.Vector = void 0;
var Point_1 = require("./Point");
var GlobalConfig_1 = __importDefault(require("./GlobalConfig"));
/**
 * Represents a 2 dimensional vector.
 */
var Vector = /** @class */ (function () {
    /**
     * Constructs a vector.
     *
     * @param w
     * This is the third component in the vector. This component is used when
     * for example performing transformations. Then a matrix multiplication might
     * result in the w component becoming not equal to 1. In this case one should
     * normalize the vector so that w becomes one again to have a valid vector.
     *
     * Why does this happen with matrix multiplications? Well most often it doesn't,
     * for example translate operations or rotations don't cause this. But if you use
     * Skew operations, this is might happen. I'd need to read up on it more myself
     * to have a better answer.
     */
    function Vector(x, y, w) {
        this.x = x;
        this.y = y;
        this.w = w;
        if (this.w === undefined) {
            this.w = 1;
        }
    }
    Vector.fromArray = function (a) {
        return new Vector(a[0], a[1], a[2]);
    };
    /**
     * Gives the dot product between the two vectors.
     * @param v2
     */
    Vector.prototype.dot = function (v2) {
        return this.x * v2.x + this.y * v2.y;
    };
    /**
     * Returns this vector as an array of numbers as [x, y, w]
     */
    Vector.prototype.asArray = function () {
        return [this.x, this.y, this.w];
    };
    /**
     * Returns a point with the same x and y as this vector.
     */
    Vector.prototype.asPoint = function () {
        return new Point_1.Point(this.x, this.y);
    };
    /**
     * Return true if this vector is pointing in the same direction
     * as the other vector.
     */
    Vector.prototype.parallel = function (other) {
        return Math.abs(this.cross(other)) <= GlobalConfig_1.default.precisionSquared;
    };
    /**
     * Returns the scalar value of the cross product between this vector and v2.
     * Normally cross product is performed in three dimensions, but here we assume
     * z value equals 0, and returns then the size of the resulting z dimension.
     * @param v2
     */
    Vector.prototype.cross = function (v2) {
        return this.x * v2.y - this.y * v2.x;
    };
    /**
     * Returns the perpendicular component vector of this vector compared to another vector.
     */
    Vector.prototype.perpendicularComponentTo = function (other) {
        if (other.isNullVector()) {
            return this;
        }
        var projectedOnto = this.projectOnto(other);
        return this.minus(projectedOnto);
    };
    /**
     * Returns this vector projected onto the other vector.
     */
    Vector.prototype.projectOnto = function (other) {
        if (other.isNullVector()) {
            return this;
        }
        var otherNormed = other.normed();
        var factor = this.dot(otherNormed);
        return otherNormed.scale(factor);
    };
    /**
     * Returns this vector in string form.
     */
    Vector.prototype.toString = function () {
        return "[" + this.x + ", " + this.y + "]";
    };
    /**
     * Returns the clockwise perpendicular vector to this one.
     * A perpendicular vector can be found by defining a vector where
     * the dot product equals 0. Now, there will be two perpendicular vectors,
     * one that is defined clockwise, and one that is found counter clockwise.
     */
    Vector.prototype.clockwisePerpendicular = function () {
        return new Vector(this.y, -this.x);
    };
    /**
     * Returns a vector pointing in the opposite direction of this vector.
     */
    Vector.prototype.reverse = function () {
        return new Vector(-this.x, -this.y);
    };
    /**
     * Returns a vector that is normalized to have norm2 = 1, pointing in the same
     * direction as this vector.
     */
    Vector.prototype.normed = function () {
        var norm2 = this.norm2();
        if (norm2 === 0) {
            throw Error('Can not norm a vector of size 0!');
        }
        return new Vector(this.x / norm2, this.y / norm2);
    };
    /**
     * Returns a new vector that is this vector multiplied by the given scalar.
     * @param factor
     */
    Vector.prototype.scale = function (factor) {
        return new Vector(this.x * factor, this.y * factor);
    };
    /**
     * This vector dot producted with itself.
     */
    Vector.prototype.square = function () {
        return this.dot(this);
    };
    /**
     * Returns whether this vector is the null vector (x and y components are null) or not.
     */
    Vector.prototype.isNullVector = function () {
        return this.x === 0 && this.y === 0;
    };
    /**
     * The euclidean length of this vector.
     */
    Vector.prototype.norm2 = function () {
        return Math.sqrt(this.square());
    };
    /**
     * Returns the vector that is this vector plus another one.
     */
    Vector.prototype.plus = function (other) {
        return vector(this.x + other.x, this.y + other.y);
    };
    /**
     * Returns this vector minus the other vector.
     */
    Vector.prototype.minus = function (other) {
        return this.plus(other.reverse());
    };
    Vector.null = new Vector(0, 0);
    return Vector;
}());
exports.Vector = Vector;
/**
  * Creates a vector
  */
function vector(x, y) {
    return new Vector(x, y);
}
exports.vector = vector;
//# sourceMappingURL=Vector.js.map