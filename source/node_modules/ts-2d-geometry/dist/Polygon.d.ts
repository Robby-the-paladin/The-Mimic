import { LineSegment } from './LineSegment';
import { Point } from './Point';
import { Vector } from './Vector';
import { Optional } from '@ruffy/ts-optional';
import { Rectangle } from './Rectangle';
/**
 * Checks if any of the given line segments in an array intersect any of the other.
 */
export declare function lineSegmentsIntersectThemselves(lineSegments: LineSegment[]): boolean;
/**
 * A polygon is defined by a number of line segments that enclose an area.
 */
export declare class Polygon {
    lineSegments: LineSegment[];
    private constructor();
    /**
     * Creates a Polygon from the given points. The points should preferably be
     * given clockwise for the polygon, but if they are not, the given line segments
     * will be corrected to make sure that they are clockwise oriented. The points are
     * also not allowed to define lines that intersect other lines in the polygon.
     * Ie. giving [0,0], [1,1], [1,0], [0,1] would not be allowed since line segments would
     * intersect in the point [0.5, 0.5].
     * @param points
     * The given points that define the polygon. Lines are defined between points next
     * to each other in the array.
     */
    static fromPoints(points: Point[]): Polygon;
    /**
     * Verifies whether a point reside inside this polygon or not.
     * If the point is positioned at the periphery,
     * it should be
     * considered as not contained.
     * @param p
     */
    containsPoint(p: Point): boolean;
    /**
     * Returns a new polygon that is like this polygon with all points moved.
     * @param x
     * @param y
     */
    translate(x: number, y: number): Polygon;
    /**
     * Returns a moved version of this polygon with all points moved.
     */
    translateByVector(v: Vector): Polygon;
    /**
     * Finds the shortest distance, if it exists, that would make the
     * point p hit this polygons perimiter when going in the defined direction.
     */
    distanceToPerimiter(p: Point, direction: Vector): Optional<number>;
    /**
     * Returns the closest point on the polygon's perimiter to the given point.
     * @param p
     * The point that we want to get the closest point to.
     */
    closestPoint(p: Point): Point;
    /**
     * Gives a readable representation of this polygon.
     */
    toString(): string;
    /**
     * Return the middle point of this polygon. This is given by finding the smallest possible
     * rectangle that encompasses the polygon, and returning the middle of that.
     */
    middle(): Point;
    /**
     * Returns the first segment that is intersected by the argument segment,
     * and the point where they intersect. Returns none if no
     * intersect exists.
     * @param ls
     */
    private firstIntersectionSegmentAndPoint;
    /**
     * Returns a set with tuples of all the intersecting points and the
     * corresponding line segment where they intersect.
     * @param ls
     */
    private intersectionSegmentAndPoints;
    /**
     * Merges this polygon and the other polygon into one shape. If no overlap is found
     * between the polygons exception is thrown.
     * @param other
     * Polygon to merge this polygon with.
     */
    merge(other: Polygon): Polygon;
    /**
     * Identifies if this polygon somehow overlaps the other polygon.
     */
    overlap(otherPolygon: Polygon): boolean;
    /**
     * Checks if this polygon and the other polygon contains the same points.
     * @param other
     * Polygon to compare with.
     */
    equals(other: Polygon): boolean;
    /**
     * Returns the line segment that starts from point p, throws exception
     * if no such line segment exists.
     * @param p
     */
    private lineSegmentFrom;
    /**
     * Checks if this polygon contains any of the points of the other polygon.
     * @param other
     * Polygon whose points are or are not part of this polygon.
     */
    private containsAnyPolygonPoint;
    /**
     * Finds the smallest possible vector in the given direction that this
     * polygon can be translated so that it no longer overlaps the
     * other polygon. If they already don't overlap, a null vector
     * is returned.
     * @param other
     * The other polygon that we should no longer overlap
     * @param direction
     * The direction that this polygon should be moved until it no longer overlaps the
     * other polygon
     */
    separationVector(other: Polygon, direction: Vector): Vector;
    /**
     * Returns the points that constitute this polygon as an array.
     */
    points(): Point[];
    bounds(): Rectangle;
    /**
     * Returns a Polygon that is expanded by 'size' units compared to this one.
     * @param size
     * number of units the polygon should expand.
     */
    swell(size: number): Polygon;
}
/**
 * This function is based on the idea that the cross product between v1 and v2 is
 * norm(v1) * norm(v2) * sin(alpha) where
 * alpha is the angle between the vectors. By going through each line segment as a vector and
 * taking the cross product,
 * we see if sin(alpha) is mostly positive or negative. Positive here meaning the vectors
 * are turning right, negative meaning they are turning left.
 * @param lineSegments
 * Array of line segments to check, note that they have to define a polygon by defining a
 * closed shape (ie. the last line must end where the first line starts.).
 */
export declare function isClockwise(lineSegments: LineSegment[]): Boolean;
/**
 * Creates a polygon based on the points that are given as an array of two dimensional
 * arrays with numbers.
 * @param points
 * array of two dimensional arrays with points.
 */
export declare function polygon(points: number[][]): Polygon;
//# sourceMappingURL=Polygon.d.ts.map