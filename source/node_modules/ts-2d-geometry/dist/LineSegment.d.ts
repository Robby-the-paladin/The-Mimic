import { Point } from './Point';
import { Line } from './Line';
import { Vector } from './Vector';
import { IntervalType } from './Interval';
import { Optional } from '@ruffy/ts-optional';
/**
 * A LineSegment is defined by two points, it represents the line between these points.
 */
export declare class LineSegment {
    p1: Point;
    p2: Point;
    constructor(p1: Point, p2: Point);
    /**
     * Creates a LineSegment from four numbers. The first two being x and y from the start point
     * of the line segment, the last two the x and y value of the end point.
     */
    static fromValues(x1: number, y1: number, x2: number, y2: number): LineSegment;
    /**
     * Creates a LineSegment from an array of numbers. The array must be at least 4 elements long
     * and these first 4 values will be used as [x1, y1, x2, y2].
     */
    static fromArray(a: number[]): LineSegment;
    /**
     * Gets the closest point on the line segment to the given point.
     * @param p2
     * Point to get closest point for.
     */
    closestPoint(p2: Point): Point;
    /**
     * Returns the point where the given line intersect this line segment, if such
     * point exists. If the line and the line segment are parallel and on the same
     * line, none is returned because there is no one unique point of intersect.
     */
    intersectForLine(l: Line): Optional<Point>;
    /**
     * Verifies if the given point is on the line that would be defined by p1 and p2 of this line
     * segment.
     * @param p
     * The point to verify
     */
    onLine(p: Point): boolean;
    /**
     * Returns boolean whether this segment is placed to the right of given point.
     * This is defined as if whether a line segment starting at point p, and going
     * to x = infinity, intersect this line segment.
     * If the point is on the line segment, false is returned,
     * @param p
     * Point to check if line segemnt is to the right of
     * @param intervalType
     * Tells us if endpoints should be part of interval or not.
     */
    rightOfPoint(p: Point, intervalType?: IntervalType): boolean;
    /**
     * Returns new line segment that is like this segment moved.
     * @param x
     * @param y
     */
    translate(x: number, y: number): LineSegment;
    /**
     * Checks if this line segment is parallel to another line segment.
     * Parallel will also hold true if the line segments overlap,
     * or lie on the same axis. I.e. [0,0] -> [1,0] is deemed parallel to [1,0] -> [2,0]
     * @param other
     * The line segment to do the comparison on.
     */
    parallel(other: LineSegment): boolean;
    /**
     * Checks if there is any overlapping point between the two line segments.
     * This is like intersect, but returns a boolean and will also return
     * true if the line segments are parallel and share one or more common points.
     */
    overlap(other: LineSegment): boolean;
    /**
     * Gives a string representing this line segment that's readable.
     */
    toString(): string;
    private getHeightInterval;
    /**
     * Returns the vector defined by going from point p1 to point p2
     */
    asVector(): Vector;
    /**
     * Returns the point where the given line segments intersect, if such point exists.
     * If the line segments are parallel none is return since the intersect can potentially
     * be many points.
     * @param ls2
     * The other line segment.
     * @param otherInterval
     * How the endpoints should be interpreted of the other line segment.
     * @param thisInterval
     * How the endpoints should be interpreted on this line segment.
     */
    intersect(ls2: LineSegment, otherInterval?: IntervalType, thisInterval?: IntervalType): Optional<Point>;
    /**
     * Returns a new Line Segment where p1 equals the new p instead.
     * @param p
     */
    startFrom(p: Point): LineSegment;
    /**
     * Return true if the points of this line segment equals the points of the other line segment.
     * @param ls
     * Line segment to compare with.
     */
    equals(ls: LineSegment): boolean;
    /**
     * Returns if the given point exists on this line segment or not.
     * @param p
     */
    containsPoint(p: Point, interval?: IntervalType): boolean;
    asLine(): Line;
    /**
     * Returns a new Line Segment where p1 and p2 have changed places.
     */
    flip(): LineSegment;
}
/**
 * Creates a line segment.
 */
export declare function lineSegment(x1: number, y1: number, x2: number, y2: number): LineSegment;
//# sourceMappingURL=LineSegment.d.ts.map