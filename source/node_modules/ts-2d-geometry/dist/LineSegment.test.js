"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Point_1 = require("./Point");
var LineSegment_1 = require("./LineSegment");
var Line_1 = require("./Line");
var Interval_1 = require("./Interval");
var Vector_1 = require("./Vector");
var ts_optional_1 = require("@ruffy/ts-optional");
var ls = new LineSegment_1.LineSegment(new Point_1.Point(0, 0), new Point_1.Point(1, 0));
test('constructor should create line segment', function () {
    expect(ls.p1).toEqual(new Point_1.Point(0, 0));
    expect(ls.p2).toEqual(new Point_1.Point(1, 0));
});
test('closestPoint should find closest point', function () {
    expect(ls.closestPoint(new Point_1.Point(0.5, -1))).toEqual(new Point_1.Point(0.5, 0));
    expect(ls.closestPoint(new Point_1.Point(-1, -1))).toEqual(new Point_1.Point(0, 0));
    expect(ls.closestPoint(new Point_1.Point(2, -1))).toEqual(new Point_1.Point(1, 0));
    var newLs = new LineSegment_1.LineSegment(new Point_1.Point(0, 0), new Point_1.Point(10, 0));
    expect(newLs.closestPoint(new Point_1.Point(5, -5))).toEqual(new Point_1.Point(5, 0));
    newLs = new LineSegment_1.LineSegment(new Point_1.Point(10, 0), new Point_1.Point(10, 10));
    expect(newLs.closestPoint(new Point_1.Point(15, 5))).toEqual(new Point_1.Point(10, 5));
    newLs = new LineSegment_1.LineSegment(new Point_1.Point(10, 10), new Point_1.Point(0, 10));
    expect(newLs.closestPoint(new Point_1.Point(5, -5))).toEqual(new Point_1.Point(5, 10));
});
test('asVector should return the vector from p1 to p2', function () {
    var v = ls.asVector();
    expect(v).toEqual(new Vector_1.Vector(1, 0));
});
test('onLine should return false if point is not on line defined by points', function () {
    expect(ls.onLine(Point_1.point(-5, 1))).toBeFalsy();
});
test('onLine should return true if point is on line defined by points', function () {
    expect(ls.onLine(Point_1.point(-5, 0))).toBeTruthy();
});
test('onLine should return true if point is on endpoints', function () {
    expect(ls.onLine(Point_1.point(0, 0))).toBeTruthy();
    expect(ls.onLine(Point_1.point(1, 0))).toBeTruthy();
});
test('flip should return a new line segment with p1 and p2 flipped', function () {
    var flipped = ls.flip();
    expect(ls.p1).toEqual(flipped.p2);
    expect(ls.p2).toEqual(flipped.p1);
});
test('intersect should return intersection point if lines intersect', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, 0, 0, 2);
    var ls2 = LineSegment_1.LineSegment.fromValues(-1, 1, 1, 1);
    expect(ls1.intersect(ls2)).toEqual(ts_optional_1.some(new Point_1.Point(0, 1)));
});
test('intersect should return point if intersection happens at endpoints', function () {
    expect(LineSegment_1.lineSegment(2, 0, 3, 1).intersect(LineSegment_1.lineSegment(1, 0, 2, 0))).toEqual(ts_optional_1.some(Point_1.point(2, 0)));
    expect(LineSegment_1.lineSegment(0, 1, 1, 0).intersect(LineSegment_1.lineSegment(1, 0, 2, 0))).toEqual(ts_optional_1.some(Point_1.point(1, 0)));
});
test('intersect should return none if point not on both lines', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, -2, 0, 0);
    var ls2 = LineSegment_1.LineSegment.fromValues(-3, 1, -1, 1);
    expect(ls1.intersect(ls2)).toBe(ts_optional_1.none);
});
[
    [[317, 128, 803, 460], [482, 180, 482, 424]],
    [[317, 128, 803, 460], [680, 424, 680, 180]],
].
    forEach(function (p) {
    test("intersect between " + p[0] + " and " + p[1] + " should exist", function () {
        var ls1 = LineSegment_1.LineSegment.fromArray(p[0]);
        var ls2 = LineSegment_1.LineSegment.fromArray(p[1]);
        expect(ls1.intersect(ls2)).not.toBe(ts_optional_1.none);
    });
});
test('rightOfPoint should return false if line segment is not on same height.', function () {
    var ls = LineSegment_1.LineSegment.fromValues(0, 0, 0, 1);
    expect(ls.rightOfPoint(Point_1.Point.fromValues(-1, 2))).toBeFalsy();
});
test('rightOfPoint should return false if line segments p1 is just right of point (it is not included in interval)', function () {
    var ls = LineSegment_1.LineSegment.fromValues(0, 0, 0, 1);
    expect(ls.rightOfPoint(Point_1.Point.fromValues(-1, 0), Interval_1.IntervalType.OpenStart)).toBeFalsy();
});
test('rightOfPoint should return true if line segment is right of point', function () {
    var ls = LineSegment_1.LineSegment.fromValues(0, 0, 0, 1);
    expect(ls.rightOfPoint(Point_1.Point.fromValues(-1, 0.5))).toBeTruthy();
});
test('rightOfPoint should return true if line segment is right of point and parallel', function () {
    var ls = LineSegment_1.LineSegment.fromValues(0, 0, 0, 1);
    expect(ls.rightOfPoint(Point_1.Point.fromValues(-1, 0))).toBeTruthy();
});
test('rightOfPoint should return false if line segment is left of point and parallel', function () {
    var ls = LineSegment_1.LineSegment.fromValues(0, 0, 0, 1);
    expect(ls.rightOfPoint(Point_1.Point.fromValues(4, 0))).toBeFalsy();
});
test('rightOfPoint should return true if line segment is horizontal and point is left of end interval', function () {
    var ls = LineSegment_1.LineSegment.fromValues(0, 0, 1, 0);
    expect(ls.rightOfPoint(Point_1.Point.fromValues(-1, 0))).toBeTruthy();
});
test('rightOfPoint should return false if line segment is left of point', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, 0, 0, 1);
    expect(ls1.rightOfPoint(Point_1.Point.fromValues(1, 0.5))).toBeFalsy();
    var ls2 = LineSegment_1.LineSegment.fromValues(0, 1, 0, 0);
    expect(ls2.rightOfPoint(Point_1.Point.fromValues(1, 0.5))).toBeFalsy();
});
test('rightOfPoint should handle end points', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, 1, 0, 0);
    expect(ls1.rightOfPoint(Point_1.Point.fromValues(-1, 0), Interval_1.IntervalType.OpenStart)).toBeTruthy();
    expect(ls1.rightOfPoint(Point_1.Point.fromValues(-1, 0), Interval_1.IntervalType.OpenEnd)).toBeFalsy();
    expect(ls1.rightOfPoint(Point_1.Point.fromValues(-1, 0), Interval_1.IntervalType.Open)).toBeFalsy();
    expect(ls1.rightOfPoint(Point_1.Point.fromValues(-1, 0), Interval_1.IntervalType.Closed)).toBeTruthy();
});
test('translate should create new line segment that is moved', function () {
    var transp = ls.translate(1, 2);
    expect(transp.p1).toEqual(ls.p1.translate(1, 2));
    expect(transp.p2).toEqual(ls.p2.translate(1, 2));
});
test('containsPoint should return true when point is on line segment', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, 0, 0, 2);
    expect(ls1.containsPoint(new Point_1.Point(0, 1))).toBeTruthy();
    expect(ls1.containsPoint(new Point_1.Point(0, 0))).toBeTruthy();
    expect(ls1.containsPoint(new Point_1.Point(0, 2))).toBeTruthy();
});
test('containsPoint should return false when point is not on line segment', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, 0, 0, 2);
    var ls2 = LineSegment_1.LineSegment.fromValues(0, 0, 2, 0);
    expect(ls1.containsPoint(new Point_1.Point(0, -1))).toBeFalsy();
    expect(ls1.containsPoint(new Point_1.Point(0, 3))).toBeFalsy();
    expect(ls1.containsPoint(new Point_1.Point(0, -3))).toBeFalsy();
    expect(ls2.containsPoint(new Point_1.Point(2.1, 0))).toBeFalsy();
    expect(ls2.containsPoint(new Point_1.Point(3, 0))).toBeFalsy();
    expect(ls2.containsPoint(new Point_1.Point(3, 0))).toBeFalsy();
    expect(ls1.containsPoint(new Point_1.Point(0.1, 1))).toBeFalsy();
});
test('containsPoint should handle interval type', function () {
    var ls1 = LineSegment_1.LineSegment.fromValues(0, 0, 0, 2);
    expect(ls1.containsPoint(Point_1.point(0, 0), Interval_1.IntervalType.Closed)).toBeTruthy();
    expect(ls1.containsPoint(Point_1.point(0, 0), Interval_1.IntervalType.OpenStart)).toBeFalsy();
    expect(ls1.containsPoint(Point_1.point(0, 0), Interval_1.IntervalType.OpenEnd)).toBeTruthy();
    expect(ls1.containsPoint(Point_1.point(0, 0), Interval_1.IntervalType.Open)).toBeFalsy();
});
test('startFrom should return new Line Segment starting from p', function () {
    var p = Point_1.Point.fromValues(50, 23);
    var ls2 = ls.startFrom(p);
    expect(ls).not.toEqual(ls2);
    expect(ls2).toEqual(new LineSegment_1.LineSegment(p, ls.p2));
});
test('equals should return true when lines are equal', function () {
    var ls = LineSegment_1.lineSegment(0, 0, 1, 0);
    var ls2 = LineSegment_1.lineSegment(0, 0, 1, 0);
    expect(ls.equals(ls)).toBeTruthy();
    expect(ls.equals(ls2)).toBeTruthy();
});
test('equals should return false when lines are not equal', function () {
    var ls = LineSegment_1.lineSegment(0, 0, 1, 0);
    var ls2 = LineSegment_1.lineSegment(1, 0, 0, 0);
    expect(ls.equals(ls.translate(1, 0))).toBeFalsy();
    expect(ls.equals(ls2)).toBeFalsy();
});
test('parallel should return true when lines are parallel', function () {
    expect(LineSegment_1.lineSegment(0, 0, 1, 0).parallel(LineSegment_1.lineSegment(0, 1, 1, 1))).toBeTruthy();
    expect(LineSegment_1.lineSegment(0, 0, 1, 0).parallel(LineSegment_1.lineSegment(0, 0, 1, 0))).toBeTruthy();
    expect(LineSegment_1.lineSegment(0, 0, 3, 17.12).parallel(LineSegment_1.lineSegment(0, 0, 6, 34.24))).toBeTruthy();
});
test('parallel should return false when lines are not parallel', function () {
    expect(LineSegment_1.lineSegment(0, 0, 1, 0).parallel(LineSegment_1.lineSegment(0, 1, 1, 2))).toBeFalsy();
});
[
    { ls1: LineSegment_1.lineSegment(-1, 0, 1, 0), ls2: LineSegment_1.lineSegment(0, -1, 0, 1), overlap: true },
    { ls1: LineSegment_1.lineSegment(-1, 2, 1, 2), ls2: LineSegment_1.lineSegment(0, -1, 0, 1), overlap: false },
    { ls1: LineSegment_1.lineSegment(0, 0, 1, 0), ls2: LineSegment_1.lineSegment(.5, 0, 1.5, 0), overlap: true },
    { ls1: LineSegment_1.lineSegment(0, 0, 1, 0), ls2: LineSegment_1.lineSegment(1, 0, 2, 0), overlap: true },
    { ls1: LineSegment_1.lineSegment(0, 0, 1, 0), ls2: LineSegment_1.lineSegment(1.1, 0, 2, 0), overlap: false },
    { ls1: LineSegment_1.lineSegment(0, 0, 10, 0), ls2: LineSegment_1.lineSegment(2, 0, 3, 0), overlap: true },
].forEach(function (_a) {
    var ls1 = _a.ls1, ls2 = _a.ls2, overlap = _a.overlap;
    test(ls1 + " " + ls2 + " should have overlap=" + overlap, function () {
        var result = ls1.overlap(ls2);
        expect(result).toBe(overlap);
    });
});
[
    { l: Line_1.line(0, 0, 1, 0), p: ts_optional_1.some(Point_1.point(0, 0)) },
    { l: Line_1.line(0, 1, 1, 0), p: ts_optional_1.some(Point_1.point(0, 1)) },
    { l: Line_1.line(0, -1, 1, 0), p: ts_optional_1.some(Point_1.point(0, -1)) },
    { l: Line_1.line(0, 2, 1, 0), p: ts_optional_1.none },
].forEach(function (_a) {
    var l = _a.l, p = _a.p;
    test("intersectForLine for line (" + l.p.x + ", " + l.p.y + " " + l.v.x + ", " + l.v.y + ") is correct", function () {
        var ls = LineSegment_1.lineSegment(0, -1, 0, 1);
        expect(ls.intersectForLine(l)).toEqual(p);
    });
});
//# sourceMappingURL=LineSegment.test.js.map