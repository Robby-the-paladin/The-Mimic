"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rectangle = exports.Rectangle = void 0;
var Point_1 = require("./Point");
var Vector_1 = require("./Vector");
var ts_optional_1 = require("@ruffy/ts-optional");
var Polygon_1 = require("./Polygon");
/**
 * A rectangle is defined by two points, the top left point, called topLeft,
 * and the bottom right point called bottomRight.
 */
var Rectangle = /** @class */ (function () {
    function Rectangle(topLeft, bottomRight) {
        this.topLeft = topLeft;
        this.bottomRight = bottomRight;
        if (topLeft.x > bottomRight.x || topLeft.y > bottomRight.y) {
            throw Error(topLeft + " must be top left compared to " + bottomRight);
        }
    }
    Rectangle.prototype.toPolygon = function () {
        var points = [
            this.topLeft,
            Point_1.point(this.bottomRight.x, this.topLeft.y),
            this.bottomRight,
            Point_1.point(this.topLeft.x, this.bottomRight.y),
        ];
        return Polygon_1.Polygon.fromPoints(points);
    };
    Rectangle.prototype.toString = function () {
        return "tl: " + this.topLeft + ", br: " + this.bottomRight;
    };
    /**
     * Method that gets the vector needed to separate this rectangle from another rectangle.
     * If there is no overlap a null vector is returned.
     */
    Rectangle.prototype.separationVector = function (other, direction) {
        if (!this.overlap(other)) {
            return Vector_1.Vector.null;
        }
        var multipliers = [
            safeDivide(other.bottomRight.x - this.topLeft.x, direction.x),
            safeDivide(other.bottomRight.y - this.topLeft.y, direction.y),
            safeDivide(other.topLeft.x - this.bottomRight.x, direction.x),
            safeDivide(other.topLeft.y - this.bottomRight.y, direction.y),
        ]
            .filter(function (a) { return a.nonEmpty(); })
            .map(function (a) { return a.get(); })
            .filter(function (a) { return a > 0; })
            .sort();
        var smallestPositiveMultiplier = multipliers[0];
        return direction.scale(smallestPositiveMultiplier);
        function safeDivide(dividend, divisor) {
            if (divisor === 0) {
                return ts_optional_1.none;
            }
            return ts_optional_1.some(dividend / divisor);
        }
    };
    /**
     * Check if there is an overlap between this and another rectangle.
     */
    Rectangle.prototype.overlap = function (other) {
        if (this.topLeft.x >= other.bottomRight.x || this.bottomRight.x <= other.topLeft.x) {
            return false;
        }
        if (this.topLeft.y >= other.bottomRight.y || this.bottomRight.y <= other.topLeft.y) {
            return false;
        }
        return true;
    };
    return Rectangle;
}());
exports.Rectangle = Rectangle;
/**
 * Function that constructs a rectangle from the two given points.
 */
function rectangle(x1, y1, x2, y2) {
    return new Rectangle(new Point_1.Point(x1, y1), new Point_1.Point(x2, y2));
}
exports.rectangle = rectangle;
//# sourceMappingURL=Rectangle.js.map