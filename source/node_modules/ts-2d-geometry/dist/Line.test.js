"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Line_1 = require("./Line");
var Vector_1 = require("./Vector");
var Point_1 = require("./Point");
var ts_optional_1 = require("@ruffy/ts-optional");
var l = new Line_1.Line(new Point_1.Point(0, 0), new Vector_1.Vector(1, 0));
beforeEach(function () {
    l = new Line_1.Line(new Point_1.Point(0, 0), new Vector_1.Vector(1, 0));
});
test('constructor should create Line', function () {
    expect(l.p).toEqual(new Point_1.Point(0, 0));
    expect(l.v).toEqual(new Vector_1.Vector(1, 0));
});
test('project should project point to line', function () {
    expect(l.project(new Point_1.Point(0.5, -1))).toEqual(new Point_1.Point(0.5, 0));
});
test('projectFactor should get factor for v to reach projection from p', function () {
    expect(l.projectFactor(new Point_1.Point(0.5, -1))).toEqual(0.5);
});
test('projectDistanceSquare should get square of projection distance', function () {
    expect(l.projectDistanceSquare(new Point_1.Point(0.5, -2))).toBe(4);
});
test('projectDistance should get projection distance', function () {
    expect(l.projectDistance(new Point_1.Point(0.5, -2))).toBe(2);
});
test('line should throw exception if null vector', function () {
    expect(function () {
        Line_1.line(0, 0, 0, 0);
    }).toThrow();
});
test('line should define line', function () {
    expect(Line_1.line(0, 0, 1, 0)).toEqual(new Line_1.Line(Point_1.point(0, 0), Vector_1.vector(1, 0)));
});
test('intersect should return none if lines are parallel', function () {
    expect(l.intersect(new Line_1.Line(new Point_1.Point(0, 1), new Vector_1.Vector(1, 0)))).toBe(ts_optional_1.none);
});
test('intersect should return intersecting point', function () {
    var l2 = new Line_1.Line(new Point_1.Point(1, 1), new Vector_1.Vector(0, 1));
    expect(l.intersect(l2)).toEqual(ts_optional_1.some(new Point_1.Point(1, 0)));
});
//# sourceMappingURL=Line.test.js.map