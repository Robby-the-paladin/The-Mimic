import { Matrix3x3 } from './Matrix3x3';
import { Point } from './Point';
import { Polygon } from './Polygon';
import { Vector } from './Vector';
/**
 * A transformation can be applied to geometrical shaped to move them according to specific rules.
 *
 * Under the hood the transformation is basically an Matrix, but
 * it works as an adapter that glues together the interface
 * of the geometrical shapes with the matrix classes.
 */
export declare class Transformation {
    private m;
    /**
     *
     * @param m
     * The transformation as describe by a matrix.
     */
    constructor(m: Matrix3x3);
    /**
     * Returns a builder that can construct a transformation.
     */
    static builder(): TransformationBuilder;
    /**
     * Applies this transformation to a point.
     */
    applyToPoint(p: Point): Point;
    /**
     * Returns a string representation of the matrix that represents this
     * transformation.
     */
    toString(): string;
    /**
     * Applies this transformation to a polygon.
     */
    applyToPolygon(pol: Polygon): Polygon;
}
/**
 * Builds a transformation by stringing together an array of
 * transformation matrices. With the first one defined in the
 * builder being the first one that is applied to the geometrical
 * shape etc.
 */
declare class TransformationBuilder {
    operations: Matrix3x3[];
    constructor();
    build(): Transformation;
    private static fromOperations;
    /**
     * Rotates the coordinates the given amount of degrees around origo.
     */
    withRotationDegrees(degrees: number): TransformationBuilder;
    /**
     * Rotates so that the positive x axis points in the direction
     * of the given vector direction.
     * @param vec
     * The vector that will become the new x-axis in the new coordinate system.
     */
    withVectorRotation(vec: Vector): TransformationBuilder;
    /**
     * Moves the points the given distance in x and y.
     */
    withTranslation(x: number, y: number): TransformationBuilder;
    /**
     * Adds an arbitrary transformation matrix to the builder.
     */
    withMatrix(m: Matrix3x3): TransformationBuilder;
    /**
     * Scales the coordinate with the given factors. If only xFactor is given, the same factor
     * will be used to scale in y direction.
     * @param xFactor
     * The factor that coordinates should be multiplied in the x-axis
     * @param yFactor
     * The factor that coordintaes should be multiplied in the y-axis
     */
    withScale(xFactor: number, yFactor?: number): TransformationBuilder;
    private createNewBuilder;
}
export {};
//# sourceMappingURL=Transformation.d.ts.map