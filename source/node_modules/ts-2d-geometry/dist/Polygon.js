"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.polygon = exports.isClockwise = exports.Polygon = exports.lineSegmentsIntersectThemselves = void 0;
var Interval_1 = require("./Interval");
var LineSegment_1 = require("./LineSegment");
var Point_1 = require("./Point");
var Vector_1 = require("./Vector");
var Line_1 = require("./Line");
var ts_optional_1 = require("@ruffy/ts-optional");
var Rectangle_1 = require("./Rectangle");
/**
 * Checks if any of the given line segments in an array intersect any of the other.
 */
function lineSegmentsIntersectThemselves(lineSegments) {
    for (var i = 0; i < lineSegments.length; i += 1) {
        var ls1 = lineSegments[i];
        for (var j = i + 1; j < lineSegments.length; j += 1) {
            var ls2 = lineSegments[j];
            if (ls2.intersect(ls1, Interval_1.IntervalType.OpenStart, Interval_1.IntervalType.OpenStart).nonEmpty()) {
                return true;
            }
        }
    }
    return false;
}
exports.lineSegmentsIntersectThemselves = lineSegmentsIntersectThemselves;
/**
 * A polygon is defined by a number of line segments that enclose an area.
 */
var Polygon = /** @class */ (function () {
    function Polygon(lineSegments) {
        this.lineSegments = lineSegments;
        if (lineSegmentsIntersectThemselves(lineSegments)) {
            throw Error('Points in polygon are intersecting themselves, this is not allowed!');
        }
        if (!isClockwise(lineSegments)) {
            this.lineSegments = lineSegments.map(function (ls) { return ls.flip(); }).reverse();
        }
    }
    /**
     * Creates a Polygon from the given points. The points should preferably be
     * given clockwise for the polygon, but if they are not, the given line segments
     * will be corrected to make sure that they are clockwise oriented. The points are
     * also not allowed to define lines that intersect other lines in the polygon.
     * Ie. giving [0,0], [1,1], [1,0], [0,1] would not be allowed since line segments would
     * intersect in the point [0.5, 0.5].
     * @param points
     * The given points that define the polygon. Lines are defined between points next
     * to each other in the array.
     */
    Polygon.fromPoints = function (points) {
        var lineSegments = points.reduce(function (a, v, i) {
            var nextIndex = (i + 1) % points.length;
            var ls = new LineSegment_1.LineSegment(points[i], points[nextIndex]);
            a.push(ls);
            return a;
        }, []);
        return new Polygon(lineSegments);
    };
    /**
     * Verifies whether a point reside inside this polygon or not.
     * If the point is positioned at the periphery,
     * it should be
     * considered as not contained.
     * @param p
     */
    Polygon.prototype.containsPoint = function (p) {
        if (this.lineSegments.find(function (ls) { return ls.containsPoint(p); })) {
            return false;
        }
        var intersectedLines = this.lineSegments.reduce(function (a, ls) {
            return ls.rightOfPoint(p, Interval_1.IntervalType.Closed)
                && !ls.onLine(p) ? a + 1 : a;
        }, 0);
        return intersectedLines % 2 === 1;
    };
    /**
     * Returns a new polygon that is like this polygon with all points moved.
     * @param x
     * @param y
     */
    Polygon.prototype.translate = function (x, y) {
        return new Polygon(this.lineSegments.map(function (ls) { return ls.translate(x, y); }));
    };
    /**
     * Returns a moved version of this polygon with all points moved.
     */
    Polygon.prototype.translateByVector = function (v) {
        return this.translate(v.x, v.y);
    };
    /**
     * Finds the shortest distance, if it exists, that would make the
     * point p hit this polygons perimiter when going in the defined direction.
     */
    Polygon.prototype.distanceToPerimiter = function (p, direction) {
        var line = p.asLine(direction);
        var shortestDistanceSquared = this.lineSegments.reduce(function (a, ls) {
            var intersectPoint = ls.intersectForLine(line);
            return intersectPoint
                .filter(function (ip) { return ip.minus(p).dot(direction) >= 0; }) // verify that inters. is in vector direction
                .map(function (ip) { return ip.distanceSquare(p); })
                .filter(function (dist) { return a.getOrElse(dist) >= dist; })
                .or(function () { return a; });
        }, ts_optional_1.none);
        return shortestDistanceSquared.map(function (d) { return Math.sqrt(d); });
    };
    /**
     * Returns the closest point on the polygon's perimiter to the given point.
     * @param p
     * The point that we want to get the closest point to.
     */
    Polygon.prototype.closestPoint = function (p) {
        var closestDist = Number.MAX_SAFE_INTEGER;
        var closestPoint = new Point_1.Point(0, 0);
        this.lineSegments.forEach(function (ls) {
            var bestPoint = ls.closestPoint(p);
            var dist = p.distanceSquare(bestPoint);
            if (dist < closestDist) {
                closestDist = dist;
                closestPoint = bestPoint;
            }
        });
        return closestPoint;
    };
    /**
     * Gives a readable representation of this polygon.
     */
    Polygon.prototype.toString = function () {
        var points = this.points();
        return "" + points;
    };
    /**
     * Return the middle point of this polygon. This is given by finding the smallest possible
     * rectangle that encompasses the polygon, and returning the middle of that.
     */
    Polygon.prototype.middle = function () {
        var bounds = this.bounds();
        return Point_1.point((bounds.topLeft.x + bounds.bottomRight.x) / 2, (bounds.topLeft.y + bounds.bottomRight.y) / 2);
    };
    /**
     * Returns the first segment that is intersected by the argument segment,
     * and the point where they intersect. Returns none if no
     * intersect exists.
     * @param ls
     */
    Polygon.prototype.firstIntersectionSegmentAndPoint = function (ls) {
        var intersections = this.intersectionSegmentAndPoints(ls);
        var startPoint = ls.p1;
        var sortedPoints = Array.from(intersections)
            .sort(function (p1, p2) { return startPoint.distanceSquare(p1[1]) - startPoint.distanceSquare(p2[1]); });
        return sortedPoints.length > 0 ? ts_optional_1.some(sortedPoints[0]) : ts_optional_1.none;
    };
    /**
     * Returns a set with tuples of all the intersecting points and the
     * corresponding line segment where they intersect.
     * @param ls
     */
    Polygon.prototype.intersectionSegmentAndPoints = function (ls) {
        return this.lineSegments.reduce(function (a, v) {
            var p = v.intersect(ls, Interval_1.IntervalType.OpenStart, Interval_1.IntervalType.OpenStart);
            p.foreach(function (p) { return a.add([v, p]); });
            return a;
        }, new Set());
    };
    /**
     * Merges this polygon and the other polygon into one shape. If no overlap is found
     * between the polygons exception is thrown.
     * @param other
     * Polygon to merge this polygon with.
     */
    Polygon.prototype.merge = function (other) {
        var _a;
        /* tslint:disable */
        var pol1 = this;
        /* tslint:enable */
        var pol2 = other;
        var currentSegment = pol1.lineSegments.find(function (ls) { return !pol2.containsPoint(ls.p1); });
        if (currentSegment === undefined) {
            return pol2;
        }
        var otherInitial = pol2.lineSegments.find(function (ls) { return !pol1.containsPoint(ls.p1); });
        if (otherInitial === undefined) {
            return pol1;
        }
        var circleComplete = false;
        var newPoint;
        var points = [];
        points.push(currentSegment.p1);
        var currentPol = pol1;
        var otherPol = pol2;
        while (!circleComplete) {
            _a = getNextStep(currentSegment, currentPol, otherPol), newPoint = _a[0], currentSegment = _a[1], currentPol = _a[2], otherPol = _a[3];
            if (points.find(function (p) { return p.equals(newPoint); }) === undefined) {
                points.push(newPoint);
            }
            else {
                circleComplete = true;
            }
        }
        function getNextStep(currentSegment, thisPolygon, otherPolygon) {
            var intersectOpt = otherPolygon.firstIntersectionSegmentAndPoint(currentSegment);
            return intersectOpt.map(function (intersection) {
                return [intersection[1],
                    intersection[0].startFrom(intersection[1]),
                    otherPolygon,
                    thisPolygon];
            }).getOrElse([currentSegment.p2,
                thisPolygon.lineSegmentFrom(currentSegment.p2),
                thisPolygon,
                otherPolygon]);
        }
        return Polygon.fromPoints(points);
    };
    /**
     * Identifies if this polygon somehow overlaps the other polygon.
     */
    Polygon.prototype.overlap = function (otherPolygon) {
        if (this.equals(otherPolygon)) {
            return true;
        }
        if (this.containsAnyPolygonPoint(otherPolygon)
            || otherPolygon.containsAnyPolygonPoint(this)) {
            return true;
        }
        return this.lineSegments.find(function (ls) {
            var inter = otherPolygon.lineSegments.find(function (ls2) { return ls.intersect(ls2, Interval_1.IntervalType.Closed, Interval_1.IntervalType.Open)
                .nonEmpty(); });
            return inter !== undefined;
        }) !== undefined;
    };
    /**
     * Checks if this polygon and the other polygon contains the same points.
     * @param other
     * Polygon to compare with.
     */
    Polygon.prototype.equals = function (other) {
        if (this.lineSegments.length !== other.lineSegments.length) {
            return false;
        }
        return this.lineSegments.reduce(function (a, v) { return a
            && other.lineSegments.find(function (ls) { return ls.equals(v); }) !== undefined; }, true);
    };
    /**
     * Returns the line segment that starts from point p, throws exception
     * if no such line segment exists.
     * @param p
     */
    Polygon.prototype.lineSegmentFrom = function (p) {
        var ls = this.lineSegments.find(function (ls) { return ls.p1.x === p.x && ls.p1.y === p.y; });
        if (ls) {
            return ls;
        }
        throw Error("No line segment found starting from " + p.x + ", " + p.y + "!");
    };
    /**
     * Checks if this polygon contains any of the points of the other polygon.
     * @param other
     * Polygon whose points are or are not part of this polygon.
     */
    Polygon.prototype.containsAnyPolygonPoint = function (other) {
        var _this = this;
        var contained = other.lineSegments.find(function (ls) { return _this.containsPoint(ls.p1); });
        return contained !== undefined;
    };
    /**
     * Finds the smallest possible vector in the given direction that this
     * polygon can be translated so that it no longer overlaps the
     * other polygon. If they already don't overlap, a null vector
     * is returned.
     * @param other
     * The other polygon that we should no longer overlap
     * @param direction
     * The direction that this polygon should be moved until it no longer overlaps the
     * other polygon
     */
    Polygon.prototype.separationVector = function (other, direction) {
        var thisBounds = this.bounds();
        var otherBounds = other.bounds();
        if (!thisBounds.overlap(otherBounds) && !this.overlap(other)) {
            return Vector_1.Vector.null;
        }
        var separateVector = thisBounds.separationVector(otherBounds, direction);
        var thisMovedFar = this.translateByVector(separateVector);
        var distancesFromThisToOther = thisMovedFar.points()
            .map(function (p) { return other.distanceToPerimiter(p, direction.reverse()); });
        var distancesFromOtherToThis = other.points()
            .map(function (p) { return thisMovedFar.distanceToPerimiter(p, direction); });
        var allDistances = distancesFromOtherToThis
            .concat(distancesFromThisToOther)
            .filter(function (distOpt) { return distOpt.nonEmpty(); })
            .map(function (distOpt) { return distOpt.get(); })
            .sort();
        var shortestDistance = allDistances[0];
        var translateVector = separateVector.plus(direction
            .reverse()
            .normed()
            .scale(shortestDistance));
        return translateVector;
    };
    /**
     * Returns the points that constitute this polygon as an array.
     */
    Polygon.prototype.points = function () {
        return this.lineSegments.map(function (ls) { return ls.p1; });
    };
    Polygon.prototype.bounds = function () {
        var points = this.points();
        var coords = points.reduce(function (a, v) {
            a[0] = Math.min(v.x, a[0]);
            a[1] = Math.min(v.y, a[1]);
            a[2] = Math.max(v.x, a[2]);
            a[3] = Math.max(v.y, a[3]);
            return a;
        }, [points[0].x, points[0].y, points[0].x, points[0].y]);
        return Rectangle_1.rectangle(coords[0], coords[1], coords[2], coords[3]);
    };
    /**
     * Returns a Polygon that is expanded by 'size' units compared to this one.
     * @param size
     * number of units the polygon should expand.
     */
    Polygon.prototype.swell = function (size) {
        var lines = this.lineSegments.map(function (ls) {
            var segmentVector = ls.asVector();
            var growVector = segmentVector.
                clockwisePerpendicular()
                .reverse()
                .normed()
                .scale(size);
            return new Line_1.Line(ls.p1.plus(growVector), segmentVector);
        });
        var newPoints = lines.map(function (v, i, array) {
            var nextIndex = (i + 1) % array.length;
            return array[i].intersect(array[nextIndex]);
        }).filter(function (p) { return p.nonEmpty(); }).map(function (p) { return p.get(); });
        return Polygon.fromPoints(newPoints);
    };
    return Polygon;
}());
exports.Polygon = Polygon;
/**
 * This function is based on the idea that the cross product between v1 and v2 is
 * norm(v1) * norm(v2) * sin(alpha) where
 * alpha is the angle between the vectors. By going through each line segment as a vector and
 * taking the cross product,
 * we see if sin(alpha) is mostly positive or negative. Positive here meaning the vectors
 * are turning right, negative meaning they are turning left.
 * @param lineSegments
 * Array of line segments to check, note that they have to define a polygon by defining a
 * closed shape (ie. the last line must end where the first line starts.).
 */
function isClockwise(lineSegments) {
    return 0 > lineSegments
        .map(function (ls) { return ls.asVector(); })
        .reduce(function (sum, v, i, array) {
        var nextIndex = (i + 1) % array.length;
        return sum + array[i].cross(array[nextIndex]);
    }, 0);
}
exports.isClockwise = isClockwise;
/**
 * Creates a polygon based on the points that are given as an array of two dimensional
 * arrays with numbers.
 * @param points
 * array of two dimensional arrays with points.
 */
function polygon(points) {
    var p = points.map(function (num) { return new Point_1.Point(num[0], num[1]); });
    return Polygon.fromPoints(p);
}
exports.polygon = polygon;
//# sourceMappingURL=Polygon.js.map