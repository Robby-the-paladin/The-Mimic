"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Matrix3x3 = void 0;
var Matrix2x2_1 = require("./Matrix2x2");
var ts_optional_1 = require("@ruffy/ts-optional");
var GlobalConfig_1 = __importDefault(require("./GlobalConfig"));
/**
 * Represents a 3x3 matrix.
 */
var Matrix3x3 = /** @class */ (function () {
    function Matrix3x3(elements) {
        this.elements = elements;
    }
    /**
     * Returns a rotation matrix with the given degrees. that rotates
     * a vector clockwise.
     */
    Matrix3x3.rotationDegrees = function (degrees) {
        var radians = degrees * Math.PI / 180.0;
        var negativeRadians = -radians; // rotation matrix is counter clockwise.
        var components = [
            Math.cos(negativeRadians),
            -Math.sin(negativeRadians),
            0,
            Math.sin(negativeRadians),
            Math.cos(negativeRadians),
            0,
            0, 0, 1,
        ];
        return Matrix3x3.fromArray(components);
    };
    /**
     * Returns a transform matrix that moves a point
     * by x, y.
     */
    Matrix3x3.translation = function (x, y) {
        var components = [
            1,
            0,
            x,
            0,
            1,
            y,
            0,
            0,
            1,
        ];
        return Matrix3x3.fromArray(components);
    };
    /**
     * Returns an identity matrix 3x3.
     */
    Matrix3x3.identity = function () {
        var components = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
        ];
        return Matrix3x3.fromArray(components);
    };
    /**
     * Returns a 3x3 Matrix from an array. The element
     * in the array are given in the following places:
     * [(0,0), (1,0), (2,0), (0,1), (1,1), (2,1),
     * (0,2), (1,2), (2,2)]
     */
    Matrix3x3.fromArray = function (a) {
        return new Matrix3x3([[a[0], a[1], a[2]],
            [a[3], a[4], a[5]],
            [a[6], a[7], a[8]]]);
    };
    /**
     * Returns the element in the given position.
     * @param y
     * The y of the element.
     * @param x
     * The x of the element
     */
    Matrix3x3.prototype.get = function (y, x) {
        return this.elements[y][x];
    };
    /**
     * Multiplies this matrix with another matrix.
     */
    Matrix3x3.prototype.timesMatrix = function (m) {
        var newMatrixArray = [];
        for (var i = 0; i < 3; i += 1) {
            newMatrixArray[i] = [];
            for (var j = 0; j < 3; j += 1) {
                newMatrixArray[i][j] = 0;
                for (var k = 0; k < 3; k += 1) {
                    newMatrixArray[i][j] += this.elements[i][k] *
                        m.elements[k][j];
                }
            }
        }
        return new Matrix3x3(newMatrixArray);
    };
    /**
     * Multiplies this matrix with an array of numbers.
     * @param vArray
     */
    Matrix3x3.prototype.times = function (vArray) {
        var newArray = this.elements.map(function (a) { return a.reduce(function (a, v, i) { return a + v * vArray[i]; }, 0); });
        return newArray;
    };
    /**
     * Returns a string representation of this matrix.
     */
    Matrix3x3.prototype.toString = function () {
        var innerString = this.elements.map(function (a) { return a.map(function (e) { return "" + e; }).join(' '); }).join('\n');
        return "[" + innerString + "]";
    };
    /**
     * Returns an inversed version of this matrix.
     */
    Matrix3x3.prototype.inverse = function () {
        var det = this.det();
        if (Math.abs(det) < GlobalConfig_1.default.precision) {
            return ts_optional_1.none;
        }
        return ts_optional_1.some(this.transpose().adjugate().scale(1 / det));
    };
    /**
     * Returns a version of this matrix where all elements are multiplied
     * by the given scalar.
     */
    Matrix3x3.prototype.scale = function (scalar) {
        var newElements = this.elements.map(function (a) { return a.map(function (v) { return v * scalar; }); });
        return new Matrix3x3(newElements);
    };
    /**
     * Returns the transpose of this matrix.
     */
    Matrix3x3.prototype.transpose = function () {
        var newElements = [];
        for (var i = 0; i < 3; i += 1) {
            newElements[i] = [];
            for (var j = 0; j < 3; j += 1) {
                newElements[i][j] = this.elements[j][i];
            }
        }
        return new Matrix3x3(newElements);
    };
    /**
     * Finds the adjugate matrix for this matrix.
     */
    Matrix3x3.prototype.adjugate = function () {
        var elements = [];
        for (var i = 0; i < 3; i += 1) {
            elements[i] = [];
            for (var j = 0; j < 3; j += 1) {
                elements[i][j] = this.subMatrixExcludingPosition(i, j).det();
            }
        }
        return new Matrix3x3(elements);
    };
    /**
     * Gets the sub matrix excluding a given position. This is used to
     * calculate the adjugate for example. This method always makes the top left
     * element of the new matrix to be the element at the bottom right of the
     * excluded position. If the excluded position is the bottom right of the matrix,
     * the selection wraps and hence chooses the top left of the main matrix
     * to be the top left position of the sub matrix.
     */
    Matrix3x3.prototype.subMatrixExcludingPosition = function (x, y) {
        var elements = [
            this.get(this.bound(x + 1), this.bound(y + 1)),
            this.get(this.bound(x + 2), this.bound(y + 1)),
            this.get(this.bound(x + 1), this.bound(y + 2)),
            this.get(this.bound(x + 2), this.bound(y + 2)),
        ];
        return Matrix2x2_1.Matrix2x2.fromArray(elements);
    };
    /**
     * Returns a value in the interval [0, 2]. By adding or subtracting
     * 3 to the input value.
     */
    Matrix3x3.prototype.bound = function (i) {
        var j = i;
        while (j < 0) {
            j += 3;
        }
        while (j > 2) {
            j -= 3;
        }
        return j;
    };
    /**
     * Calculates the determinant of the matrix.
     */
    Matrix3x3.prototype.det = function () {
        var sum = 0;
        for (var i = 0; i < 3; i += 1) {
            var posVal = 1;
            var negVal = 1;
            for (var k = 0; k < 3; k += 1) {
                posVal *= this.get(this.bound(i + k), k);
                negVal *= this.get(this.bound(i - k), k);
            }
            sum += posVal - negVal;
        }
        return sum;
    };
    return Matrix3x3;
}());
exports.Matrix3x3 = Matrix3x3;
//# sourceMappingURL=Matrix3x3.js.map