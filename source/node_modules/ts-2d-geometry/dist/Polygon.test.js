"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Point_1 = require("./Point");
var Vector_1 = require("./Vector");
var Polygon_1 = require("./Polygon");
var LineSegment_1 = require("./LineSegment");
var ts_optional_1 = require("@ruffy/ts-optional");
var Rectangle_1 = require("./Rectangle");
var pol = Polygon_1.polygon([]);
beforeEach(function () {
    pol = Polygon_1.polygon([[0, 0], [0, 1], [1, 1], [1, 0]]);
});
test('constructor should initialize polygon', function () {
    expect(pol.lineSegments.length).toBe(4);
});
test('constructor should guarantee that line segments are clockwise oriented', function () {
    var pol = Polygon_1.polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
    expect(pol.lineSegments.find(equalLineSegment(0, 0, 0, 1))).toBeDefined();
});
test('constructor should throw exception if polygon intersects itself', function () {
    expect(function () {
        var pol = Polygon_1.polygon([[0, 0], [1, 1], [1, 0], [0, 1]]);
    }).toThrow();
});
test('containsPoints should return true if point is inside Polygon.', function () {
    var pol = Polygon_1.polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
    expect(pol.containsPoint(Point_1.Point.fromValues(0.5, 0.5))).toBeTruthy();
});
test('containsPoint should return false if point is one border of Polygon.', function () {
    var pol = Polygon_1.polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
    expect(pol.containsPoint(Point_1.point(0, 0))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(1, 0))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(0, 1))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(1, 1))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(0, 0.5))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(0.5, 0))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(1, 0.5))).toBeFalsy();
    expect(pol.containsPoint(Point_1.point(0.5, 1))).toBeFalsy();
});
test('containsPoint should return false if point is outside', function () {
    var pol = Polygon_1.polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
    expect(pol.containsPoint(Point_1.Point.fromValues(-0.5, 0.5))).toBeFalsy();
    expect(pol.containsPoint(Point_1.Point.fromValues(1.5, 0.5))).toBeFalsy();
    expect(pol.containsPoint(Point_1.Point.fromValues(0.5, -0.5))).toBeFalsy();
    expect(pol.containsPoint(Point_1.Point.fromValues(0.5, 1.5))).toBeFalsy();
});
test('containsPoint should return false if point is tangent to line', function () {
    var pol = Polygon_1.polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
    expect(pol.containsPoint(Point_1.Point.fromValues(-0.5, 1))).toBeFalsy();
});
test('toString should return string', function () {
    var pol = Polygon_1.polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
    expect(pol.toString()).toBeDefined();
});
test('equals should return true when points are the same', function () {
    var pol = Polygon_1.polygon([[0, 0], [0, 1], [1, 1], [1, 0]]);
    expect(pol.equals(pol)).toBeTruthy();
    var otherPol = pol.translate(0, 0);
    expect(pol.equals(otherPol)).toBeTruthy();
});
test('equals should return true when points are the same', function () {
    var pol = Polygon_1.polygon([[0, 0], [0, 1], [1, 1], [1, 0]]);
    var pol2 = Polygon_1.polygon([[0, 1], [1, 1], [1, 0], [0, 0]]);
    var pol3 = Polygon_1.polygon([[1, 1], [1, 0], [0, 0], [0, 1]]);
    expect(pol.equals(pol2)).toBeTruthy();
    expect(pol.equals(pol3)).toBeTruthy();
});
test('equals should return false when points are not the same', function () {
    var pol = Polygon_1.polygon([[0, 0], [0, 1], [1, 1], [1, 0]]);
    var pol2 = Polygon_1.polygon([[0, 0], [0, 1], [1, 1], [1, 0], [0.5, -1]]);
    expect(pol.translate(0.5, 0).equals(pol)).toBeFalsy();
    expect(pol.equals(pol2)).toBeFalsy();
});
test('bounds should return bounds that encompasses polygon', function () {
    var pol = Polygon_1.polygon([[1, 0], [2, 1], [1, 2], [0, 1]]);
    expect(pol.bounds()).toEqual(Rectangle_1.rectangle(0, 0, 2, 2));
});
test('swell should return a new bigger polygon.', function () {
    var newPol = pol.swell(1);
    var expectedPolygon = Polygon_1.polygon([
        [-1, -1],
        [-1, 2],
        [2, 2],
        [2, -1],
    ]);
    expect(newPol.equals(expectedPolygon)).toBeTruthy();
});
test('merge should throw error if no overlap', function () {
    var pol1 = Polygon_1.polygon([
        [0, 0],
        [1, 0],
        [1, 1],
        [0, 1],
    ]);
    var pol2 = pol1.translate(2, 0);
    expect(function () { return pol1.merge(pol2); }).toThrow;
});
test('merge should return containing polygon if one contains the other.', function () {
    var swelled = pol.swell(5);
    expect(pol.merge(swelled)).toBe(swelled);
    expect(swelled.merge(pol)).toBe(swelled);
});
test('merge should merge two diamond polygons', function () {
    var pol1 = Polygon_1.polygon([
        [-1, 0],
        [0, 1],
        [1, 0],
        [0, -1],
    ]);
    var pol2 = pol1.translate(1, 0);
    expect(pol1.merge(pol2).lineSegments.length).toBe(8);
});
test('closestPoint should return closest point on perimiter.', function () {
    var pol1 = Polygon_1.polygon([
        [0, 0],
        [10, 0],
        [10, 10],
        [0, 10],
    ]);
    expect(pol1.closestPoint(new Point_1.Point(-5, 5))).toEqual(new Point_1.Point(0, 5));
    expect(pol1.closestPoint(new Point_1.Point(15, 5))).toEqual(new Point_1.Point(10, 5));
    expect(pol1.closestPoint(new Point_1.Point(5, 15))).toEqual(new Point_1.Point(5, 10));
    expect(pol1.closestPoint(new Point_1.Point(5, -5))).toEqual(new Point_1.Point(5, 0));
});
test('separationVector should return given polygon if no overlap found.', function () {
    var pol2 = pol.translate(3, 0);
    expect(pol.separationVector(pol2, Vector_1.vector(1, 0))).toEqual(Vector_1.Vector.null);
});
[
    { direction: Vector_1.vector(1, 0), expectedMove: Vector_1.vector(1, 0) },
    { direction: Vector_1.vector(2, 0), expectedMove: Vector_1.vector(1, 0) },
].forEach(function (_a) {
    var direction = _a.direction, expectedMove = _a.expectedMove;
    test("separationVector should move polygon in direction " + direction, function () {
        expect(pol.separationVector(pol, direction)).toEqual(expectedMove);
    });
});
[
    { direction: Vector_1.vector(1, 0), expectedMove: Vector_1.vector(2, 0) },
].forEach(function (_a) {
    var direction = _a.direction, expectedMove = _a.expectedMove;
    test("separationVector should manage complicated shapes in direction " + direction + ".", function () {
        var pol1 = Rectangle_1.rectangle(0, 0, 2, 2).toPolygon();
        var pol2 = Polygon_1.polygon([[1, 0], [2, 1], [1, 2], [0, 1]]);
        var result = pol2.separationVector(pol1, direction);
        expect(result).toEqual(expectedMove);
    });
});
test('bounds should return outer bounds', function () {
    var pol = Polygon_1.polygon([[1, 0], [2, 1], [1, 2], [0, 1]]);
    expect(pol.bounds()).toEqual(Rectangle_1.rectangle(0, 0, 2, 2));
    expect(Rectangle_1.rectangle(0, 0, 2, 2).toPolygon().bounds()).toEqual(Rectangle_1.rectangle(0, 0, 2, 2));
});
[
    { p: Point_1.point(0, 0), v: Vector_1.vector(1, 0), expected: ts_optional_1.some(0) },
    { p: Point_1.point(1, 0), v: Vector_1.vector(1, 0), expected: ts_optional_1.some(1) },
    { p: Point_1.point(-5, 0), v: Vector_1.vector(1, 0), expected: ts_optional_1.some(5) },
    { p: Point_1.point(0, -5), v: Vector_1.vector(0, 1), expected: ts_optional_1.some(5) },
    { p: Point_1.point(0, 5), v: Vector_1.vector(0, 1), expected: ts_optional_1.none },
].forEach(function (_a) {
    var p = _a.p, v = _a.v, expected = _a.expected;
    test("distanceToPerimiter should give " + expected + " when going from " + p + " in direction " + v + ".", function () {
        var pol = Rectangle_1.rectangle(0, 0, 2, 2).toPolygon();
        var result = pol.distanceToPerimiter(p, v);
        expect(result).toEqual(expected);
    });
});
test('middle should find middle of polygon', function () {
    expect(Polygon_1.polygon([
        [0, 0],
        [10, 0],
        [10, 10],
        [0, 10],
    ]).middle())
        .toEqual(new Point_1.Point(5, 5));
    expect(Polygon_1.polygon([
        [0, 100],
        [100, 50],
        [10, 50],
        [10, 10],
    ]).middle())
        .toEqual(new Point_1.Point(50, 55));
});
test('overlap should return false when polygons are separate', function () {
    expect(Polygon_1.polygon([
        [0, 0],
        [1, 0],
        [1, 1],
        [0, 1],
    ]).overlap(Polygon_1.polygon([
        [3, 0],
        [4, 0],
        [4, 1],
        [3, 1],
    ]))).toBeFalsy();
});
test('overlap should be true for self', function () {
    var poly = Polygon_1.polygon([
        [0, 0],
        [20, 0],
        [20, 20],
        [0, 20],
    ]);
    expect(poly.overlap(poly)).toBeTruthy();
});
test('overlap should return true when polygons contain each other', function () {
    var pol1 = Polygon_1.polygon([
        [0, 0],
        [20, 0],
        [20, 20],
        [0, 20],
    ]);
    var pol2 = Polygon_1.polygon([
        [1, 1],
        [2, 1],
        [2, 2],
        [1, 2],
    ]);
    expect(pol1.overlap(pol2)).toBeTruthy();
    expect(pol2.overlap(pol1)).toBeTruthy();
});
test('overlap should return true when polygon lines intersect', function () {
    var pol1 = Polygon_1.polygon([
        [0, 0],
        [2, 0],
        [2, 2],
        [0, 2],
    ]);
    var pol2 = pol1.translate(-1, 0);
    expect(pol1.overlap(pol2)).toBeTruthy();
    expect(pol2.overlap(pol1)).toBeTruthy();
    pol2 = Polygon_1.polygon([
        [-1, 0],
        [4, 0],
        [4, 1],
        [-1, 1],
    ]);
    expect(pol1.overlap(pol2)).toBeTruthy();
});
test('overlap should return false when polygons are adjacent', function () {
    var pol1 = Polygon_1.polygon([
        [0, 0],
        [2, 0],
        [2, 2],
        [0, 2],
    ]);
    var pol2 = pol1.translate(-2, 0);
    expect(pol1.overlap(pol2)).toBeFalsy();
});
test('translate keeps orientation of lines', function () {
    var pol = Polygon_1.polygon([[0, 0], [0, 1], [1, 1], [1, 0]]);
    var newPol = pol.translate(0, 0);
    expect(pol.equals(newPol)).toBeTruthy();
});
test('lineSegmentsIntersectThemselves should return false for simple square', function () {
    var points = [[0, 0], [0, 1], [1, 1], [1, 0]].map(function (p) { return Point_1.point(p[0], p[1]); });
    var lineSegments = points.reduce(function (a, v, i) {
        var nextIndex = (i + 1) % points.length;
        var ls = new LineSegment_1.LineSegment(points[i], points[nextIndex]);
        a.push(ls);
        return a;
    }, []);
    expect(Polygon_1.lineSegmentsIntersectThemselves(lineSegments)).toBeFalsy();
});
test('isClockwise should be false when not clockwise', function () {
    var points = [[0, 0], [1, 0], [1, 1], [0, 1]].map(function (p) { return Point_1.point(p[0], p[1]); });
    var lineSegments = points.reduce(function (a, v, i) {
        var nextIndex = (i + 1) % points.length;
        var ls = new LineSegment_1.LineSegment(points[i], points[nextIndex]);
        a.push(ls);
        return a;
    }, []);
    expect(Polygon_1.isClockwise(lineSegments)).toBeFalsy();
});
test('isClockwise should be true when clockwise', function () {
    var points = [[0, 0], [0, 1], [1, 1], [1, 0]].map(function (p) { return Point_1.point(p[0], p[1]); });
    var lineSegments = points.reduce(function (a, v, i) {
        var nextIndex = (i + 1) % points.length;
        var ls = new LineSegment_1.LineSegment(points[i], points[nextIndex]);
        a.push(ls);
        return a;
    }, []);
    expect(Polygon_1.isClockwise(lineSegments)).toBeTruthy();
});
function equalLineSegment(x1, y1, x2, y2) {
    return function (lineSegment) { return lineSegment.p1.x === x1
        && lineSegment.p1.y === y1
        && lineSegment.p2.x === x2
        && lineSegment.p2.y === y2; };
}
//# sourceMappingURL=Polygon.test.js.map