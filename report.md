# Постановка задачи
хз чё это
# Описание
Проект состоит из двух частей: игры и редактора уровней для неё

Основная часть проекта - игра с двумерной графикой с видом сверху от третьего лица в жанре stealth-action (https://en.wikipedia.org/wiki/Stealth_game). Игроку предоставляется возможность управлять монстром, который может дпередвигаться и получать контроль над второстепенными персонажами, переселяясь в них. 
Цель игрока - пройти от начальной точки уровня к конечной, оставаясь при этом в живых

Вторая часть - редактор уровней, которые могут использоваться в игре

### Механики, реализованные в игре:
* **Перемещение с учётом коллизии со стенами**. Стены представлены как сетка, в каждой клетке сетки может находиться стена, либо не находиться
* **Тайлы**. В каждой клетке карты находится изображение, состоящее из двух слоёв
* **Переселение** - игрок может вселяться в разные сущности и управлять ими
* **Модуль управления**, привязывающийся к любому персонажу. Персонажем является Монстр, либо человек
* **Здоровье и получение урона**. У каждого персонажа есть шкала здоровья, которое снижается при получении персонажем урона. Когда здоровье становится не больше нуля, персонаж погибает
* **Стрельба**
  * **Стрельба биомассой** - ей может стрелять монстр, при помощи неё осуществляется взятие контроля над другим персонажем. Для стрельбы биомассой реализована механика "рогатки" - чем дольше пользователь зажимает клавишу выстрела, тем больше будет скорость снаряда
  * **Стрельба оружия**. Оружием владеют солдаты и могут применять его против игрока, либо же игрок может применять его, взяв контроль над солдатом. Для ограничения стрельбы оружия реализована механика перезарядки и смены обойм
  * Для ограничения дальности полёта снаряда используется его торможение с помощью формулы вязкого трения $V' = - a V$
* **Анимации**. Реализовано 2 вида анимаций, состоящих из множества кадров:
  * **Анимации персонажей**. Анимация пероснажа представляет из себя конечный автомат, где в каждой вершине находится кадр анимации и каждый ход совершается переход к новой вершине в зависимости от состояния персонажа. Например, влияет направление движения
  * **"Анимации-призраки"**. Временные анимации, состоящие из зацикленного набора кадров. Определяются начальным и конечным состояниеми и временем существования. Состояние включает в себя позицию, размер, угол наклона, прозрачность. 
* **Камера**. Локации в игре большие, поэтому требуется перемещение камеры, которая сможет наводиться на разные участки локации. Камера реализована на уровне модуля отрисовки, все объекты отображаются с учётом текущего расположения камеры
* **Освещение**. Реализована механика динамического освещения. На игровой карте расположены источники света, каждый обладающей своей интенсивностью. Динамически расчитывается освещение для каждой клетки. При отрисовке освещение сглаживается между клетками и вышлядит плавным. Источники света могут менять свою интенсивность в процессе игры
* **Звуки**. К каждому действию в игре может быть привязан звук, который воспроизводится при выполнении действия
* **Настороженность**. У каждого человеческого персонажа есть шкала настороженности, которая влияет на его поведение
* **Триггеры**. Некоторые события создают объект Trigger, который Может быть замечен человеческими персонажами и поднять их настороженность
* **Искусственный интеллект**. Человеческие персонажи управляются искусственным интеллектом. Искуственный интеллект изолирован от прямого взаимодейстивя с характеристиками персонажа (позиция, направление движения). Вместо этого он оперирует коммадами, которые впоследстивии обрабатываются в классе персонажа. ИИ может выполнять следующие действия:
  * Прокладывание пути и следование до конкретной точки
  * Ожидание
  * Преследование и атака
  
  У ИИ может быть несколько моделей поведения. Каждая модель поведения - последовательность действий (например, несколько точек, которые надо по-очереди посетить). В игре у каждого персонажа определено 2 модели: стандартная и паническая. Если настороженность выше определённого предела, используется паническая модель, иначе стандартная

### Механики, реализованные в редакторе уровней:
* Управление камерой
* Возможность постановки тайлов
* Возможность комбинации тайлов из 2х изображений. Изображения можно выбирать из 3х разных палитр: потолков, стен и полов.
* Режим демонстрации коллизии. В нём подсвечиваются тайлы, обладающие коллизией (через которые не может пройти персонаж)
* Изменение размеров карты
* Постановка персонажей
* Редактирование моделей поведения персонажей. Отдельно редактируются паническая и стандартная модели. Можно добавлять действия, удалять их и менять порядок, использую технологию drag & drop

Дополнительные механики:
* Скрипт для разворачивания изображений из атласа. Художнику удобнее работать с набором похожих картинок в одном файле (например, с кадрами одной анимации). В игру картинки загружаются по-отдельности. Поэтому был создан скрипт для разделения одной картинки на несколько с соблюдением правил названия для корректной загрузки в игру

# Архитектура

## Язык и среда
Весь основной код написан на языке **typescript** (https://www.typescriptlang.org/), который является статически типизированной версией языка **javascript**. Такое решение было принято, чтобы облегчить процесс разработки. ИСпользования статической типизации позволяет избежать многих ошибок программе ещё на этапе компиляции.

С точки зрения пользователя, проект открывается как HTML-документ

Проект представляет из себя набор файлов с расширением **.ts**. В файле **tsconfig.json** указываются предписание к сборке. Специальной командой из множества .ts-файлов компилируется файл build.ts, который уже подключается к HRML-документу в качестве скриптового файла

Обе части проекта (игра и редакторуровней) используют общие классы для удобства кодирования и расшифровки уровня в json

## Устройство классов
Для приложения используетс модель объектно-ориентированного программирования. За каждый процесс отвечает отдельный класс. Далее перечислены основные классы, необходимые для
### Game
Главным классом в проекте является `Game`. Он отвечает за игровую логику и хранит в себе массивы всех объектов
### Entity
Класс сущности. Все экземпляры этого класса являются видимыми игровыми объектами, между которыми и происходит взаимодействие

Для класса **Entity** определены:
* Ссылка на объект **Game**, внутри которого создана сущность
* Физическое тело. Объект типа **Body**. Для него прописано физическое взаимодействие с миром
* Уровень зоровья
* Метод, который вызывается на каждом шаге программы
* Способ отрисовки, определяемый методом **display**
* Метод **die**, завершающий существование сущности и передающий объекту **Game** сигнал об этом

Класс **Entity** является базовым, от которого наследуются другие сущности:
* **Person**. Для него определена система команд и взаимодействия с ИИ и модулем контроля. Обладает моделью поведения (см. ниже). Объекты класса **Person** могут передвигаться и выполнять действия. В зависимости от уровня здоровья может принимать одно из трёх состояний: *fine*, *corrupted*, *dying*. Существуют следующие подтипы **Person**:
   * **Monster**. Класс монстра. Если объект такого типа существует, то всегда должен управляться игроком. При создании, к объекту **Monster** крепится триггер (см. ниже)
   * **Scientist**. Учёный, обычно управляется с помощью ИИ
   * **Soldier**. Отличается от учёного тем, что имеет функционал стрельбы и объект оружия, который этот функционал и реализует
* **StationaryObject**. Неподвижный предмет
  * **Corpse**. Труп, создаётся при смерти персонажа, в него нельзя вселяться (см. ниже)
* **Projectile**. Снаряд, который может двигаться по прямой в пространстве. Особенностью движения являются наличие вязкого трения, ограничевающего скорость, и возможности отскока от стен. Существуют следущие подтипы:
  * **Biomass**. Снаряд,выпускаемый мимиком, необходимый для реализации механики переселения
  * **CombatProjectile**. Снаряд, создающийся оружием, способен наносить урон другим сущностям
  
Классы, связанные с **Entity**:
* **Body**. Физическое тело. Обладает позицией в пространстве. Для него определён метод `move`, который овершает перемещение тела на заданный вектор в пространстве с учётом коллизии со стенами
* **Animation**. Класс анимации персонажа. Представляет из себя конечный автомат, где в каждой вершине находится кадр анимации и каждый ход совершается переход к новой вершине в зависимости от состояния персонажа по здоровью (*fine*, *corrupted*, *dying*) и его направления движения
* **Commands**. Хранит простейшие команды такие как движение в выбранном направлении и стрельба. Команды интерпретируются и исполняются в **Person**
* **AI**. Класс, отвечающий за искуственный интеллект. Реализует инструкции: 
  * Ожидание
  * Следование к точке
  * Приследование
* **BehaviorModel**. Модель поведения. Хранит в себе последовательности инструкций в зависимости от состояния персонажа по настороженности (*standart* либо *panic*). Инструкции интерпретируются в **AI** и переводятся в комманды
* **Weapon**. Оружие. Реализует механику стрельбы с учётом перезарядки и смены обойм

### Mimic
Мимик является тем, чем на самом деле управляет игрок. Через него идёт перенаправление управления от игрока к персонажу. Класс **Mimic** отвечает за механику переселения. 
 
Для класса **Mimic** определены:
* Ссылка на объект **Game**, внутри которого создан мимик
* **controlledEntity**, объект типа **Entity**, который в данный момент является подконтрольным мимику
* Метод, который вызывается на каждом шаге программы
* Метод **takeControl**, отвечающий за взятие контроля над выбранной сущностью с учётом побочных эффектов
* Метод выпускания биомассы. Через него реализуется механика переселения. Происходит это следующим образом: создаётся объект класса **Biomass**, к нему применяется **takeControl**, при попадании биомассы в другого персонажа, взятие контроля применяется к нему

### Trigger
Триггер. Конструкция, созданная, чтобы действия в игре могли влиять на поведение персонажей. При создании, к нему привязывается ссылка на объект **Entity**, из которого мы берём координаты и информацию о том, должен ли триггер существовать (триггер должен исчезать, если объект исчезает). Так же определено время жизни и сила воздействия.

Триггер, будучи увиденным (проверка триггеров реализована в классе **Person**), повышает настороженность того, кто его увидел

Триггер может действовать на каждую сущность единожды, поэтому в нём хранится список тех, на кого он уже повлиял. Если сущность уже в этом списке, на неё триггер не действует

### Control
Статический класс, отвечающий за взаимодействие с пользователем и внешней средой. Выполняет следующие функции:
* Обработка клавиатуры. Распознаёт нажатие клавиш, преобразует с помощью таблицы клавиши в абстрактные команды. Это позволяет изолировать клавиши от команд и реализовать гибкую смену управления
* Обработка мыши
* Чтение текстовых файлов

### Draw
### Sounds

## Классы общего назначения
вектор, рандом и прочее

